#ifndef PLAYER_H
#define PLAYER_H

#include "asset_holder.h"

////////////////////////////////////////////////////////////
/// \brief class dealing with player movement,collision and markers
///
/// this class handles player movement ,collision and placement
/// of collectable markers which serve as victory condition
///
////////////////////////////////////////////////////////////
class player
{
private:

	enum class move_dir_no { MOVE_NULL, MOVE_LEFT, MOVE_RIGHT, MOVE_DOWN, MOVE_UP };

	////////////////////////////////////////////////////////////
	/// \brief size of player
	///
	////////////////////////////////////////////////////////////
	float BASE_SIZE = 30.f;

	//movement variables
	////////////////////////////////////////////////////////////
	/// \brief denotes if player moving or not
	///  
	/// false denotes player is stationary and 
	/// true denotes player is moving
	///
	////////////////////////////////////////////////////////////
	bool moving;

	////////////////////////////////////////////////////////////
	/// \brief denotes movement direction
	///
	////////////////////////////////////////////////////////////
	move_dir_no movedirection;

	////////////////////////////////////////////////////////////
	/// \brief used to initialize variables
	///
	/// sets movementspeed to required value and
	/// sets movement variables moving and move direction to initial values
	///
	////////////////////////////////////////////////////////////
	void initvariables();

	////////////////////////////////////////////////////////////
	/// \brief used to initialize player shape
	///
	/// initializes size and color of player shape
	////////////////////////////////////////////////////////////
	const void initshape();

	////////////////////////////////////////////////////////////
	/// \brief denotes player movement speed
	///
	////////////////////////////////////////////////////////////
	float movementspeed;

	////////////////////////////////////////////////////////////
	/// \brief used to indicate if grid has been colored
	///
	/// true when grid colored entirely,false otherwise
	///
	////////////////////////////////////////////////////////////
	bool all_grids_colored;

	////////////////////////////////////////////////////////////
	/// \brief used to make sure grid entirely covered
	///
	/// used in updatemarkers() to ensure last bit of movement 
	////////////////////////////////////////////////////////////
	bool end_flag;

	//vector where all markers are stored
	////////////////////////////////////////////////////////////
	/// \brief storage for all markers
	///
	////////////////////////////////////////////////////////////
	std::vector<sf::RectangleShape> markers;

	////////////////////////////////////////////////////////////
	/// \brief temporary marker object
	///
	/// used to set size,color,origin of all markers
	////////////////////////////////////////////////////////////
	sf::RectangleShape marker_temp;

	////////////////////////////////////////////////////////////
	/// \brief used to ensure proper level completion
	///
    /// Used to make sure player moves certain distance after 
	/// collecting all markers before stopping so that entire 
	/// grid is colored 
	///
	////////////////////////////////////////////////////////////
	std::pair<sf::Vector2f, sf::Vector2f> ending_movement;

    //variables needed for time independent implementation

	////////////////////////////////////////////////////////////
	/// \brief denotes delta time
	///
	////////////////////////////////////////////////////////////
	float dt;

	////////////////////////////////////////////////////////////
	/// \brief denotes frame rate to be acheived
	///
	////////////////////////////////////////////////////////////
	float time_mult;

	//needed to draw trail lines

	//vector where all previously made trails are stored
	////////////////////////////////////////////////////////////
	/// \brief storage for all previously drawn trails
	///
	////////////////////////////////////////////////////////////
	std::vector<sf::RectangleShape> trails;

	////////////////////////////////////////////////////////////
	/// \brief denotes start of the trail being drawn
	///
	////////////////////////////////////////////////////////////
	sf::Vector2f start_trail;

	////////////////////////////////////////////////////////////
	/// \brief denotes end of trail at that moment
	///
	////////////////////////////////////////////////////////////
	sf::Vector2f end_trail;

	//shape which is for trail being drawn(if any)
	////////////////////////////////////////////////////////////
	/// \brief returns a trail given 2 points
	/// 
	////////////////////////////////////////////////////////////
	sf::RectangleShape curr_trail(sf::Vector2f* start, sf::Vector2f* end);

	//sets trail start depending on movement direction
	////////////////////////////////////////////////////////////
	/// \brief sets start_trail to where start of trail is, given movement direction
	///
	///  this function should only be called when movement happening 
	///  will not change start_trail variable otherwise
	/// 
	////////////////////////////////////////////////////////////
	void get_start_trail(move_dir_no, sf::FloatRect);

	//sets trail end depending on movement direction
	////////////////////////////////////////////////////////////
	/// \brief setsend_trail to where end of trail is,given movement direction
	///
	///  this function should only be called when movement happening 
	///  will not change end_trail variable otherwise
	/// 
	////////////////////////////////////////////////////////////
	void get_end_trail(move_dir_no,sf::FloatRect);

	//updates input and movement
	////////////////////////////////////////////////////////////
	/// \brief checks input,sets movement,changes start_trail accordingly
	///
	/// this function checks the input to see if movement
	/// key pressed ,changes movement accordingly and
	/// assigns a valid value to start-trail for given movement
	///
	////////////////////////////////////////////////////////////
	void updateinput();

	//checks for window collison 
	////////////////////////////////////////////////////////////
	/// \brief ensures player remains within screen 
	///
	///  checks if player is touching/out of screen and
	/// adjusts it's position and stops movement accordingly 
	///
	/// \param target pointer to window with which bounds is to be checked
	///
	////////////////////////////////////////////////////////////
	void updatewindowcollision(sf::RenderTarget* target);

	////////////////////////////////////////////////////////////
	/// \brief checks for collision with given object 
	///
	///  checks if player is colliding with object and
	/// adjusts it's position and stops movement accordingly
	///
	/// \param object pointer to object with which collision is to be checked
	///
	////////////////////////////////////////////////////////////
	void updatemarkers();

	////////////////////////////////////////////////////////////
	/// \brief stores direction in which player was most recently
	/// moving(apart from MOVE_NULL) ,same as movement_direction
	/// when it is not equal to MOVE_NULL
	///
	////////////////////////////////////////////////////////////
	move_dir_no last_moving_direction;

	////////////////////////////////////////////////////////////
	/// \brief stores moving from last update cycle
	/// 
	////////////////////////////////////////////////////////////
	bool previous_moving;

	////////////////////////////////////////////////////////////
	/// \brief stores reference to asset_holder being used in 
	/// the game
	///
	////////////////////////////////////////////////////////////
	asset_holder& m_assets;

	////////////////////////////////////////////////////////////
	/// \brief sprite which shows player texture and animations
	///
	////////////////////////////////////////////////////////////
	sf::Sprite player_sprite;

	////////////////////////////////////////////////////////////
	/// \brief array of IntRect 's used on texture to get animations and set
	/// appropriate player textures
	///
	////////////////////////////////////////////////////////////
	sf::IntRect display_frame[6];

	////////////////////////////////////////////////////////////
	/// \brief  updaates player animation
	///
	////////////////////////////////////////////////////////////
	void update_animation(float _dt);
    
	////////////////////////////////////////////////////////////
	/// \brief  float for stationary animation
	///
	////////////////////////////////////////////////////////////
	float anim_timer;

	////////////////////////////////////////////////////////////
	/// \brief  float for moving animation
	///
	////////////////////////////////////////////////////////////
	float trail_timer;

	////////////////////////////////////////////////////////////
	/// \brief  int used to cycle stationary animation
	///
	////////////////////////////////////////////////////////////
	int anim_dir;

	////////////////////////////////////////////////////////////
	/// \brief  flag used by spring to indicate bounce
	///
	////////////////////////////////////////////////////////////
	bool spring_flag;


public:

	friend class teleporter;
	friend class spring;

	////////////////////////////////////////////////////////////
	/// \brief bool to display markers
	///
	/// if set to true ,markers are displayed otherwise 
	/// not displayed
	///
	////////////////////////////////////////////////////////////
	bool display_markers;

	////////////////////////////////////////////////////////////
	/// \brief used to check if level completed
	///
	/// if returns true means that all markers were collected
	/// and level has finished(grid has been colored entirely),
	/// false means still some squares uncolored
	///
	////////////////////////////////////////////////////////////
	bool level_complete();

	////////////////////////////////////////////////////////////
	/// \brief used to add markers in chain fashion
	///
	/// enter a vector of sf::Vector2f points in player units
	/// and this function will create markers with spacing in the 
	/// x and/or y direction  equal to player length between 
	/// consecutive points in vector
	///
	/// \param points vector of sf::vector2f points
	///
	/// \note place markers in middle of grid squares
	/// 
	/// \warning no output/change if only zero or one point in vector
	///
	/// \warning if 2 consecutive points are the same 
	/// then a single marker will be generated at that position
	///
	////////////////////////////////////////////////////////////
	void add_marker_chain(const std::vector<sf::Vector2f>& points);

	////////////////////////////////////////////////////////////
	/// \brief used to add a single marker
	///
	/// enter coordinates of marker in player length units 
	/// to generate a marker at that position 
	///
	/// \param x x coordinate in player units
	/// \param y y coordinate in player units
	///
	/// \note place markers in middle of grid squares
	/// 
	////////////////////////////////////////////////////////////
	void add_marker_single(float x, float y);

	//cons and decons
	////////////////////////////////////////////////////////////
	/// \brief constructor
	///
	/// \param _x initial  x coordinate of player in player unit
	/// \param _y initial  y coordinate of player in player units
	/// \param 
	/// 
	////////////////////////////////////////////////////////////
	player(float _x , float _y,asset_holder* assets);

	////////////////////////////////////////////////////////////
	/// \brief destructor
	///
	////////////////////////////////////////////////////////////
	virtual ~player();

	////////////////////////////////////////////////////////////
	/// \brief used for square shaped player
	///
	////////////////////////////////////////////////////////////
	sf::RectangleShape shape;

	//returns coord of player object
	////////////////////////////////////////////////////////////
	/// \brief gives player coordinates
	///
	/// \return sf::vector2f showing x and y coordinates of player
	///
	////////////////////////////////////////////////////////////
	sf::Vector2f getcoord();

	////////////////////////////////////////////////////////////
	/// \brief checks for collision with given object 
	///
	///  checks if player is colliding with object and
	/// adjusts it's position and stops movement accordingly
	///
	/// \param object pointer to object with which collision is to be checked
	///
	////////////////////////////////////////////////////////////
	void update_collision(sf::RectangleShape* object);

	//generic update and vender
	////////////////////////////////////////////////////////////
	/// \brief generic update function
	///
	/// serves as container for all other update function/calls
	///
	/// \param target pointer to window in which object present
	/// \param _dt delta time value for which frame rate is adjusted
	/// \param _time_mult targeted value of fps
	/// for which frame rate independence is implemented
	///
	////////////////////////////////////////////////////////////
	void update(sf::RenderWindow* target, float* _dt, float* _time_mult);

	////////////////////////////////////////////////////////////
	/// \brief generic render function
	///
	/// serves as container for all other render functions/calls.
	///
	/// \param target pointer to window in 
	/// which object is to be rendered
	///
	////////////////////////////////////////////////////////////
	void render(sf::RenderWindow* target);

};

#endif